/**
 * scc = strongly connected components
 * t_graph = transposed graph (graph with reversed edges)
 
 * In algoritmi DFS classici, i valori d (tempo di scoperta) e f (tempo di fine visita) sono importanti.
 * Ma nel caso specifico dell’algoritmo di Kosaraju solo f (tempo di fine visita) è concettualmente 
 * importante, ma non è necessario salvarlo esplicitamente, perché l’ordine di fine visita viene già gestito tramite lo stack.
 * node.d (tempo di scoperta) → non serve.
 * node.f (tempo di fine visita) → non serve esplicitamente, perché il push sullo stack già riflette l'ordine di fine visita.
 */

dfs(graph) {                                           // Funzione principale DFS per trovare SCC
  stack = new stack();                                 // Stack per tenere traccia dell'ordine di visita

  for (node in graph.nodes) {                          // Inizializzazione dei nodi
    node.predecessor = null;                           // Nessun predecessore all'inizio
    node.color = white;                                // Tutti i nodi inizialmente bianchi (non visitati)
  }

  for (node in graph.nodes) {                          // Prima DFS per ordinare i nodi
    if (node.color == white) {                         // Se il nodo non è stato visitato
      dfs_visit_1(node, stack);                        // Chiamata alla funzione di visita
    }
  }

  t_graph = create_t_graph(graph);                     // Creazione del grafo trasposto

  for (node in t_graph.nodes) {                        // Reset dei colori nel grafo trasposto
    node.color = white;
  }

  scc = [];                                            // Lista delle componenti fortemente connesse

  while (!stack.is_empty()) {                          // Seconda DFS sul grafo trasposto
    node = stack.pop();                                // Prendiamo un nodo dallo stack
    t_node = t_graph.get_node_by_id(node.id);          // Prendiamo il nodo corrispondente nel grafo trasposto

    if (t_node.color == white) {                       // Se il nodo non è stato ancora visitato
      component = [];                                  // Nuova componente
      dfs_visit_2(t_node, component);                  // Chiamata alla funzione di visita
      scc.append(component);                           // Aggiungiamo la componente alle SCC
    }
  }

  return scc;                                          // Ritorniamo le SCC trovate
}

dfs_visit_1(node, stack) {                             // Funzione di visita per la prima DFS
  node.color = gray;                                   // Nodo in fase di visita

  for (adj_node in node.adj) {                         // Per ogni nodo adiacente
    if (adj_node.color == white) {                     // Se non è stato visitato
      adj_node.predecessor = node;                     // Assegniamo il predecessore
      dfs_visit_1(adj_node, stack);                    // Visitiamo ricorsivamente il nodo adiacente
    }
  }

  node.color = black;                                  // Nodo completamente visitato
  stack.push(node);                                    // Aggiungiamo il nodo allo stack
}

dfs_visit_2(node, component) {                         // Funzione di visita per la seconda DFS
  node.color = gray;                                   // Nodo in fase di visita
  component.append(node);                              // Aggiungiamo il nodo alla componente corrente

  for (t_adj_node in node.adj) {                       // Per ogni nodo adiacente nel grafo trasposto
    if (t_adj_node.color == white) {                   // Se non è stato visitato
      dfs_visit_2(t_adj_node, component);              // Visitiamo ricorsivamente
    }
  }

  node.color = black;                                  // Nodo completamente visitato
}

create_t_graph(graph) {                                // Funzione per creare il grafo trasposto
  t_graph = new graph();

  for (node in graph.nodes) {
    t_graph.add_node(node.id);                         // Copia dei nodi
  }

  for (node in graph.nodes) {
    for (adj_node in node.adj) {
      t_graph.get_node_by_id(adj_node.id).add_edge(t_graph.get_node_by_id(node.id)); // Inverti l’arco
    }
  }

  return t_graph;
}
