/**
 * scc = strongly connected components
 * t_graph = transposed graph (graph with reversed edges)
 */

main_alg(G){

    stack = new stack()
    time = 0 

    for node in G.nodes{
        node.color = white
        node.predecessor = null
        node.d = 0
        node.f = 0
    }

    for node in G.nodes{
        if node.color == white{
            DFS_firstPass(node, stack)
        }
    }

    t_graph = create_t_graph(G)

    for node in t_graph.nodes{
        node.color = white
    }

    ssc_list = []

    while !stack.is_empty(){
        node = stack.pop()

        if node.color == white{
            ssc = []
            DFS_secondPass(node, t_graph, scc)
            scc_list.add(scc)
        }
    }

    return scc_list
}

DFS_firstPass(node, stack){
    time = time + 1
    node.d = time 
    node.color = gray

    for adj_node in node.adj{
        if adj_node.color == white{
            DFS_firstPass(adj_node, stack)
        }
    }

    node.color = black
    time = time + 1
    node.f = time

    stack.push(node)
}

DFS_secondPass(node, t_graph, scc){

    node.color = gray
    scc.add(node)

    for adj_node in t_graph.getAdiacent(node){
        if adj_node.color == white{
            DFS_secondPass(adj_node, t_graph, scc)
        }
    }

    node.color = black
}


create_t_graph(G){

    t_graph = new graph()

    for node in G.nodes{
        for adj_node in node.adj{
            t_graph.add_node_if_not_exists(adj_node)
            t_graph.add_node_if_not_exists(node)
            t_graph.add_edge(adj_node, node)  // arco inverso!

        }
    }

    return t_graph
}